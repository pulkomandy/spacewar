/*
  Spacewar! 3.1, JS port by Norbert Landsteiner <www.masswerk.at>, March 2015.
  Updated for true implementation of the outline compiler in April 2016.
  See: <http://www.masswerk.at/spacewar/JS-Spacewar/>.

  Spacewar! was conceived in 1961 by Martin Graetz, Stephen Russell, and Wayne
  Wiitanen. It was first realized on the PDP-1 in 1962 by Stephen Russell, Peter
  Samson, Dan Edwards, and Martin Graetz, together with Alan Kotok, Steve Piner,
  and Robert A Saunders. Spacewar! is in the public domain, but this credit
  paragraph must accompany all distributed versions of the program.

  The original program was written in PDP-1 assembler code, using MIT's "Macro"
  assembler: <http://www.masswerk.at/spacewar/sources/spacewar3.1_complete.txt>

  The JS implementation is intentionally close to the original, but makes use of
  modern programming techniques, like loops, objects, and floating point math.

  The script uses intentionally a subset of JavaScript that should be comprehen-
  sible to anyone familiar with C or C-type language. (Tripple comparison opera-
  tors like '===' and '!==' are checking identiy without type-coercion.)

  The use of floating math has some effects on the implementation: multiplica-
  tions and divisision will be used to transform values (rather than shifts),
  also, some scalings in the original that are translating values to screen
  co-ordinates by a shift by 8 bits will be affected, too. (The PDP-1 uses screen
  co-ordinates in fixed point representation in one's complement, 10 significant
  integer bits and 8 fractional bits, which were used for object-positions, too.)
  The function generated by the outline compiler receives positional values and
  unit vectors for its movement matrix rather as arguments than using shared
  globals. Moreover, the JS implementation generally uses count-downs rather than
  count-ups (the PDP-1 featured only an increment instruction but no decrement).
  Otherwise the implementation is a direct port and true to the original code
  (spacewar 3.1, 24 sep 62).

  Compare the code analysis at <http://www.masswerk.at/spacewar/inside>
  and the original program in emulation at <http://www.masswerk.at/spacewar>.

  Requires an external display implementing
  - CRT.plot(<x>, <y>, <brightness>) ... plot a blip onto the screen, and
  - CRT.update() ... signal for final rendering at the end of each frame.

  Optionally, an external UI receives the folling notifications:
  - SpacewarUI.showScores(<score-ss1>, <score-ss2>) ... score display,
  - SpacewarUI.halted() ... game halted (call Spacewar.resume() to continue),
  - SpacewarUI.readGamepads() ... signal to check any controls on frame entry.
  SpacewarUI is only called, if found, any of these methods may be missing.
  The UI is expected to set player controls via Spacewar.setControls().
  Options may be specified as an argument to run() or anytime via setOption().

  ====================  Not intended for commercial use.  ====================
*/

#include <math.h>
#include <string>
#include <vector>

#include "spacewar.h"

#include "Collidible.h"
#include "Planetarium.h"

// "interesting and often changed constants"
// (original values in octal, not allowed in JS strict-mode, see comments)

                                                     // sym   value  unit/comment
                                                     // -------------------------------
static const int
	torpedoSupply =                         32,  // tno     040  (number of)
	torpedoVelocity =                        4,  // tvl  sar 4s  (right shift)
 	torpedoReloadTime =                     16,  // rlt     020  (frames)
	torpedoLife =                           96,  // tlf    0140  (frames)
	fuelSupply =                          8192,  // foo  020000  (per exhaust blip)
	spaceshipAcceleration =                  4,  // sac  sar 4s  (right shift)
	starCaptureRadius =                      1,  // str      01  (greater zero)
	collisionRadius =                       48,  // me1   06000  (screen coors)
	collisionRadius2 =                      24,  // me2   03000  (above/2)
	hyperspaceShots =                        8,  // mhs     010  (number of)
	hyperspaceTimeBeforeBreakout =          32,  // hd1     040  (frames)
	hyperspaceTimeInBreakout =              64,  // hd2    0100  (frames)
	hyperspaceRechargeTime =               128,  // hd3    0200  (frames)
	hyperspaceDisplacement =                 9,  // hr1  scl 9s  (left shift)
	hyperspaceInducedVelocity =              4,  // hr2  scl 4s  (left shift)
	hyperspcaceUncertancy =              16384;  // hur  040000  (threshold bonus)

// game settings

struct _Options {
	int ANGULARMOMENTUM ;  // sense switch 1
	int LOWGRAVITY;  // sense switch 2
	int SINGLESHOTS;  // sense switch 3
	int NOBACKGROUND;  // sense switch 4
	int SUNKILLS;  // sense switch 5
	int SUNOFF;  // sense switch 6

	int TESTWORDCONTROLS;  // use testword controls
	int HALTONSCORES;  // halt on scores/matches (call resume() to continue)
	int FPS;   // fps (original alternates between 19 and 25)

	_Options() {
		ANGULARMOMENTUM =  false;  // sense switch 1
		LOWGRAVITY =       false;  // sense switch 2
		SINGLESHOTS =      false;  // sense switch 3
        NOBACKGROUND =     false;  // sense switch 4
        SUNKILLS =         false;  // sense switch 5
        SUNOFF =           false;  // sense switch 6

        TESTWORDCONTROLS = false;  // use testword controls
        HALTONSCORES =     false;  // halt on scores/matches (call resume() to continue)
        FPS =                 22;   // fps (original alternates between 19 and 25)
	}

	int& operator[](std::string key) {
		if (key == "ANGULARMOMENTUM") return ANGULARMOMENTUM;
		if (key == "LOWGRAVITY")      return LOWGRAVITY;
		if (key == "SINGLESHOTS")     return SINGLESHOTS;
		if (key == "NOBACKGROUND")    return NOBACKGROUND;
		if (key == "SUNKILLS")        return SUNKILLS;
		if (key == "SUNOFF")          return SUNOFF;
		if (key == "TESTWORDCONTROLS") return TESTWORDCONTROLS;
		if (key == "HALTONSCORES")    return HALTONSCORES;
		/*if (key == "FPS")*/         return FPS;
	}
} Options;

// static vars

int timer;
_CRT CRT;
_UI SpacewarUI;

static constexpr int QUADRANT = COORS_MAX/2;

static constexpr double BIN_RAD_COEF = M_PI / 51472;  // PI is 51472 (0144420 oct) in PDP-1
static constexpr double TAU = M_PI * 2;               // 2 PI



static constexpr int outline1[] = {           // spaceship 1 (needle)
	1, 1, 1, 1, 3, 1,
	1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 6, 3,
	3, 1, 1, 1, 1, 1,
	1, 4, 6, 1, 1, 1,
	1, 1, 1, 1, 1, 4,
	7, 0, 0, 0, 0, 0
};

static constexpr int outline2[] = {           // spaceship 2 (wedge)
	0, 1, 3, 1, 1, 3,
	1, 1, 3, 1, 1, 1,
	1, 1, 6, 3, 1, 3,
	1, 3, 1, 1, 1, 1,
	1, 6, 1, 1, 5, 1,
	1, 1, 1, 6, 3, 3,
	3, 6, 5, 1, 1, 4,
	7, 0, 0, 0, 0, 0
};

static constexpr int nob = 24;        // number of objects

// plot int co-ordinates, normalized (x: 0..1024, y: 0..1024, origin top-left) to CRT
void plot(double x, double y, int b) {
	x = (COORS_MAX + x);
	while (x < 0) x += SCREENWIDTH;
	while (x > SCREENWIDTH) x -= SCREENWIDTH;
	y = (SCREENWIDTH - (COORS_MAX + y));
	while (y < 0) y += SCREENWIDTH;
	while (y > SCREENWIDTH) y -= SCREENWIDTH;
	CRT.plot(x, y, b);
}


std::vector<CollidibleObject*> mtb;        // table of objects

static int score1;      // score spaceship 1
static int score2;      // score spaceship 2
static int restartCounter;
static int gameCounter;
static int halted;
static unsigned int testword;

static Planetarium ExpensivePlanetarium;

struct Point {double x; double y;};
class Spaceship: public CollidibleObject {
	public:
		Spaceship()
			: CollidibleObject()
		{
			angularMomentum = 0;  //              (symbol: nom, pointer: mom)
			theta = 0;            // rotation                      (nth, mth)
			fuel = 0;             // amount of fuel                (nfu, mfu)
			torpedoes = 0;        // torpedoes left                (ntr, mtr)
			outline = NULL;       // outline code                  (not, mot)
			hyp1 = 0;             // hyperspace: handler backup    (nh1, mh1)
			hyp2 = 0;             // hyperspace jumps remaining    (nh2, mh2)
			hyp3 = 0;             // hyperspace cooling            (nh3, mh3)
			hyp4 = 0;             // hyperspace uncertainty        (nh4, mh4)
			ctrl = 0;             // control input                 (pntr cwg)
			lastCtrl = 0;         // last control word             (nco, mco)
		}

		void spaceshipHandler();
		void hyperspaceHandler();
		void hyperspaceHandler2();

        double theta;
        Point (*outline)(double, double, double, double, double, double, double, double, double, double);
        int torpedoes;
        int fuel;
		void(CollidibleObject::*hyp1)(void);
        int hyp2;
        int hyp3;
        int hyp4;
        int ctrl;
        double angularMomentum;
        int lastCtrl;
};

// object handlers, this-object is current object (see mainLoop)

void Spaceship::hyperspaceHandler2() {
	// "this routine handles a ship breaking out of hyperspace"
	if (--counter > 0) {
		// spend time in breakout, display a blip
		plot(x, y, 2);
	}
	else {
		// zero, now check, restore spaceship handler
		handler = hyp1;
		collidible = true;
		size = 1024;
		if (hyp2 > 0) hyp2--; // decrement remaining jumps
		hyp3 = hyperspaceRechargeTime;
		// now check, if we break on re-entry (Mark One Hyperfield Generators ...)
		hyp4 += hyperspcaceUncertancy;
		int r = ((int)(Random() * (1 << 20)) | 0) & 0x1FFFF; // 17-bits random
		if (hyp4 >= r) { // explode
			handler = &Spaceship::explosionHandler;
			collidible = false;
			counter = 10;
		}
	}
}

void Spaceship::hyperspaceHandler() {
	// "this routine handles a non-colliding ship invisibly in hyperspace"
	if (--counter == 0) { // spend time in hyperspace ...
		// zero, set up next step
		handler = (Handler)&Spaceship::hyperspaceHandler2;
		// this.size = 7; // not used here
		// set up displacement
		x += (Random() * 2 - 1) * (1 << hyperspaceDisplacement);
		y += (Random() * 2 - 1) * (1 << hyperspaceDisplacement);
		toroidalize(); // maintain toroidal space (not in original)
		// add induced velocity
		dx += (Random() * 2 - 1) * (1 << hyperspaceInducedVelocity);
		dy += (Random() * 2 - 1) * (1 << hyperspaceInducedVelocity);
		// set up a random rotation
		theta = TAU * Random();
		// original adds some instructions to keep it in bounds of 0 .. 2 PI
		counter = hyperspaceTimeInBreakout;
	}
}

static constexpr double angularAcceleration =     8 * BIN_RAD_COEF;  // maa     010  (turn, PI: 0144420)
void Spaceship::spaceshipHandler() {  /* (label sr0) */
	double am, Sin, Cos, bx, by, t1, t2, ssn, scn, sx1, sy1, stx, sty, ssm,
		   ssc, ssd, scm, csn, src, csm;
	int	m, f, thrusting = false;
	Point p;
	CollidibleObject* torp;
	// rotation
	am = angularMomentum;
	if (ctrl & LEFT)  am += angularAcceleration;
	if (ctrl & RIGHT) am -= angularAcceleration;
	if (Options.ANGULARMOMENTUM) {
		angularMomentum = am;
	}
	else {
		angularMomentum = 0;
		am *= 128; // 1<<7
	}
	theta += am;
	// limit to +/- 2*PI
	if (theta > TAU) {
		theta -= TAU;
	}
	else if (theta < -TAU) {
		theta += TAU;
	}
	Sin = sin(theta);
	bx = by = 0;
	// gravity computations
	if (!Options.SUNOFF) {
		t1 = x / 8;
		t2 = y / 8;
		t1 = t1 * t1 + t2 * t2;
		if (t1 < starCaptureRadius) { // in sun (label pof)
			dx = dy = 0;
			if (Options.SUNKILLS) { // explode (label po1)
				handler = &Spaceship::explosionHandler;
				collidible = false;
				counter = 8;
			}
			else { // set ship to "anti pode"
				x = y = COORS_MAX;
			}
			return;
		}
		t1 = (sqrt(t1) * t1) / 2;
		if (!Options.LOWGRAVITY) t1 /= 4;
		bx = -x / t1;
		by = -y / t1;
	}
	// ... and back to business ...
	Cos = cos(theta);
	// rockets fired?
	if ((ctrl & THRUST) && fuel) {
		f = 1 << spaceshipAcceleration; // use div instead of right shift
		by += Cos / f;
		bx -= Sin / f;
		thrusting = true;
	}
	// update positions
	dy += by;
	y  += dy / 8;
	dx += bx;
	x  += dx / 8;
	toroidalize();
	// half a ship's length
	ssn = Sin * 16;
	scn = Cos * 16;
	// outline start pos (stern, ahead of center)
	sx1 = x - ssn;
	sy1 = y + scn;
	// torpedoes will show up here
	stx = sx1 - ssn;
	sty = sy1 + scn;
	// draw the ship and update drawing pos to end of outline
	ssn = Sin;
	scn = Cos;
	ssm = ssn;
	ssc = ssn + scn;
	ssd = ssc;
	csn = ssn - scn;
	csm = -csn;
	scm = scn;
	p = outline(sx1, sy1, ssn, scn, ssm, ssc, ssd, csn, csm, scm);
	sx1 = p.x;
	sy1 = p.y;
	// draw exhausts
	if (thrusting) {
		src = floor(Random() * 16);
		ssn = Sin * 2;
		scn = Cos * 2;
		// fuel consumption is a function of the blast's length!
		while (fuel > 0 && --src > 1) {
			fuel--;
			sx1 += ssn;
			sy1 -= scn;
			plot (sx1, sy1, 0);
		}
	}
	if (counter > 0) { // torpedo cooling
		counter--;
	}
	else if ( // fire, no single-shot-lock, and torpedoes left?
			(ctrl & FIRE)
			&& (!Options.SINGLESHOTS || !(lastCtrl & FIRE))
			&& torpedoes
			) {
		torpedoes--;
		// find empty object and set up the torpedo
		for (m = 2; m < nob; m++) {
			if (!mtb[m]->handler) {
				torp = mtb[m];
				torp->handler = &Spaceship::torpedoHandler;
				torp->collidible = true;
				torp->x = stx;
				torp->y = sty;
				f = 1 << torpedoVelocity; // use div instead of right shift
				torp->dx = dx - Sin * 512 / f;
				torp->dy = dy + Cos * 512 / f;
				torp->size = 16;
				torp->counter = torpedoLife;
				counter = torpedoReloadTime;
				break;
			}
		}
	}
	// hyperspace
	if (hyp3 > 0) { // cooling
		hyp3--;
	}
	else if (hyp2 > 0) { // jumps remaining?
		// are controls for left and right set and was neither of them set before?
		// (last condition is thought to inhibit accidental jumps.
		//  ignored in original, since the last control word is never saved,
		//  works out as "if (this.ctrl) & Controls.HYPERSPACE)".)
		if ((((~ctrl) | lastCtrl) & HYPERSPACE) == 0) {
			hyp1 = handler;
			handler = (Handler)&Spaceship::hyperspaceHandler;
			collidible = false;
			counter = hyperspaceTimeBeforeBreakout;
			// this.size = 3; // not used here
		}
	}
	// store last control word (missing in original)
	lastCtrl = ctrl;
}

// optional UI notifications

static void displayScores() {
	SpacewarUI.showScores(score1, score2);
}

static void haltSignal() {
	SpacewarUI.halted();
}

// notify any external UI to check gamepads (on the entry of each frame).
// the UI is expected to set any readings via Spacewar.setControls().

static void readGamepads() {
	SpacewarUI.readGamepads();
}

// outline compiler, returns anonymous function
// variables are rather passed to the resulting function as arguments than shared as globals
// when called: f(sx1, sy1, ssn, scn, ssm, ssc, ssd, csn, csm, scm)
// generated function returns object { "x": x, "y": y },
// where x, y are the coors of the last plot position to be used for sx1 and sy1 respectively.

template<const int oc[48]> static Point compileOutline (
		double sx1, double sy1, double ssn, double scn, double ssm, double ssc,
		double ssd, double csn, double csm, double scm)
{
	// (lable oc => properties 'not', 'not+1')
	int pass1 = true,
		mark = false,
		i = 0,
		max = 48,
		mx, my, t;
	double x = sx1,
		   y = sy1;

	while (i < max) {
		switch (oc[i++]) {
			case 0: // fall through
			case 1:    // down
				x += ssn;
				y -= scn;
				plot(x, y, 0);
				break;
			case 2:  // right
				x += scm;
				y += ssm;
				plot(x, y, 0);
				break;
			case 3:    // down right
				x += ssc;
				y -= csm;
				plot(x, y, 0);
				break;
			case 4: // left
				x -= scm;
				y -= ssm;
				plot(x, y, 0);
				break;
			case 5:    // down left
				x += csn;
				y -= ssd;
				plot(x, y, 0);
				break;
			case 6: // store/restore position
				if (mark) {
					x = mx;
					y = my;
				}
				else {
					mx = x;
					my = y;
				}
				mark = !mark;
				break;
			case 7: // mirror / return
				if (pass1) {
					// flip matrix horizontally
					scm = -scm;
					ssm = -ssm;
					t = csm;
					csm = ssd;
					ssd = t;
					t = ssc;
					ssc = csn;
					csn = t;
					// start over
					i = 0;
					x = sx1;
					y = sy1;
					pass1 = false;
					mark = false; // fix any orphaned codes 6 (not in original)
				}
				else {
					// return last plotting position
					return {
						x,
							y
					};
				}
				break;
		}
	}
	// failsafe return -- not in original, we should have returned at code 7 before!
	return {
		x,
			y
	};
}

static void newGame() {  /* (label a40) */
	int i;
	Spaceship* ss1;
	Spaceship* ss2;

	ss1 = new Spaceship();
	ss2 = new Spaceship();

	// clear and init table of objects (label a2)
	for(auto i: mtb)
		delete i;
	mtb.clear();
	mtb.push_back(ss1);
	mtb.push_back(ss2);
	for (i = 2; i < nob; i++) mtb.push_back( new CollidibleObject() );

	// setup spaceships (label a2, a3)
	ss1->handler = (CollidibleObject::Handler)&Spaceship::spaceshipHandler;
	ss1->collidible = true;
	ss2->handler = (CollidibleObject::Handler)&Spaceship::spaceshipHandler;
	ss2->collidible = true;
	ss1->x =  QUADRANT;
	ss1->y =  QUADRANT;
	ss2->x = -QUADRANT;
	ss2->y = -QUADRANT;
	ss1->theta = M_PI;
	ss2->theta = 0;
	ss1->outline = compileOutline<outline1>;
	ss2->outline = compileOutline<outline2>;
	ss1->torpedoes = ss2->torpedoes = torpedoSupply;
	ss1->fuel = ss2->fuel = fuelSupply;
	ss1->hyp2 = ss2->hyp2 = hyperspaceShots;
	// explosion size will be derived from this (orig: instruction count)
	ss1->size = ss2->size = 1024;
}

// draw the gravitational star

static void starp(double& x, double& y, double bx, double by) {
	x += bx;
	y += by;
	plot(x, y, 0);
}

static void drawHeavyStar() { // (label blp)
	double x = 0,
		   y = 0,
		   bx = Random() * 2 -1,
		   by = Random() * 2 -1,
		   l = 16 - floor(Random()*8);
	int i;

	plot(x, y, 0);
	for (i = 0; i < l; i++) starp(x, y, bx, by);
	x = -x;
	y = -y;
	for (i = 0; i < l; i++) starp(x, y, bx, by);
}




static void mainLoop() {  /* (label ml0, ml1) */
	CollidibleObject* obj1;
	CollidibleObject* obj2;
	int	nnn = nob - 1;
	// loop over objects
	for (int i = 0; i < nnn; i++) {
		obj1 = mtb[i];
		// is it active?
		if (obj1->handler) {
			// can it colide?
			if (obj1->collidible) {
				// comparison loop
				for (int j = i + 1; j < nob; j++) {
					obj2 = mtb[j];
					// collidible?
					if (obj2->collidible) {
						double dx = fabs(obj1->x - obj2->x);
						if (dx  < collisionRadius) {
							double dy = fabs(obj1->y - obj2->y);
							if (dy < collisionRadius && dx + dy < collisionRadius2) {
								// explode
								obj1->handler = obj2->handler = &CollidibleObject::explosionHandler;
								obj1->collidible = obj2->collidible = false;
								// set up explosion time & size
								obj1->counter = obj2->counter = (obj1->size + obj2->size - 1) >> 8;
							}
						}
					}
				}
			}
			// call the object's method
			(obj1->*obj1->handler)();
		}
	}
	// handle last object, if any
	obj1 = mtb[nnn];
	if (obj1->handler) (obj1->*obj1->handler)();

	if (!Options.NOBACKGROUND)
		ExpensivePlanetarium.update(); // background stars
	if (!Options.SUNOFF)
		drawHeavyStar();    // gravtational star ("sun")
}

static void frame() {  /* (label a) */
	Spaceship* ss1;
	Spaceship* ss2;
	int thriving1, thriving2, endOfMatch = false;
	if (!halted) {

		// end of game and restart checks, executed at start of each frame
		// (these were external patches in version 2b)
		if (restartCounter == 0) {  /* (label a6) */
			// here after halt (scores display) or at first run
			if ((testword & 32) == 0) {
				// clear scores on testword bit 5 zero
				score1 = score2 = 0;
				displayScores(); // notify UI, if found
				// read new number of games for match play (0 .. 31)
				gameCounter = (testword >> 6) & 31;
			}
			newGame();
		}
		// check, if ships are alive and have any torpedoes left
		ss1 = (Spaceship*)mtb[0];
		ss2 = (Spaceship*)mtb[1];
		thriving1 = (ss1->handler == (CollidibleObject::Handler)&Spaceship::spaceshipHandler);
		thriving2 = (ss2->handler == (CollidibleObject::Handler)&Spaceship::spaceshipHandler);
		if (thriving1 && thriving2
				&& (ss1->torpedoes > 0 || ss2->torpedoes > 0)) {
			// reset restart-counter
			restartCounter = 2 * torpedoLife;
		}
		else if (--restartCounter == 0) { // count down to scoring
			// count-down reached: whoever is still alive is awarded a score
			if (thriving1) score1 = (score1 + 1) % 0x3FFFF; // 18 bit overflow
			if (thriving2) score2 = (score2 + 1) % 0x3FFFF;
			displayScores(); // display scores anyway (original see below)
			// check match-play
			if (gameCounter > 0) {
				if (--gameCounter == 0) { // count down
					// end of a match
					if (score1 == score2) {
						// it's a tie, one more game
						gameCounter = 1;
					}
					else {
						endOfMatch = true;
					}
				}
			}
			// halt (to show scores), if match over or bit 5 in testword set,
			// else start over
			if (endOfMatch || (testword & 32)) {
				// original puts score 1 into AC and score 2 in IO and halts
				// displayScores();
				if (Options.HALTONSCORES) {
					halted = true;
					haltSignal(); // notify UI, if found
				}
				return; // we'll resume at the top, since restartCounter is still zero
			}
			else {
				// no special case, restart the game
				newGame();
				restartCounter = 1; // not in original (fix resume-after-halt logic)
			}
		}

		// finally advance to the main loop ...
		// (in the original program input is read at the start of each spaceship handler)
		// read special input (normally expected to be set by 'Spacewar.setControls()')
		if (Options.TESTWORDCONTROLS) {
			// map testword bits to spaceship controls
			((Spaceship*)mtb[0])->ctrl = (testword >> 14) & 15;
			((Spaceship*)mtb[1])->ctrl = testword & 15;
		}
		readGamepads();
		mainLoop();
	}
	CRT.update(); // external UI, not in original
}

// main -- start a game
void Spacewar::run(char* options[])
{
	// initialize any sense switch flags (optional)
	// e.g., Spacewar.run( { SUNKILLS: true } );
	//for (int k = 0; options[k]; k++) setOption(k, options[k]);

	// start the game
	ExpensivePlanetarium.reset();
	restartCounter = 0;
	frame();
	if (timer) clearInterval(timer);
	timer = setInterval(frame, floor(1000 / Options.FPS));
}

static constexpr bool legalInputs[] = { false, true, true, false, true, false, false, false, true, false, false, false, true, false, false, true };
/*
   setter for spaceship control input
   Spacewar.setControls( 0, FIRE, true )
   reset state by Spacewar.setControls( 0, RESET )
   or    Spacewar.setControls( 0, ALL, false )
*/
void Spacewar::setControls(int spaceship, int key, int value)
{
	if (mtb.empty()) return; // not started, yet: ignore
	// sanitize input
	int s = spaceship | 0;
	if (s < 0 || s > 1) return;
	int b = key | 0;
	if (!legalInputs[b]) return;

	// finally, manipulate the bit-vector in property 'ctrl'
	Spaceship* obj = (Spaceship*)mtb[s];
	obj->ctrl = ( (value)? obj->ctrl | b : obj->ctrl & (~b) ) & ALL;
}


// ship outline codes

/*
   the screen is represented internally like the DEC type 30 display:
   1048 x 1048 at 7 intensities, origin at the center.
   while the original uses a fixed point format (fx10.18) for positions,
   floats are used in the JS implementation.
   intensities are 3 bit values, one's complement (+3 .. -3).
   higher intensities also cause bigger spot-sizes (blips).
   the original display is a point plotted device (animated display),
   meaning there's no memory or frame buffer: blips will be activated
   and fade away (in the afterglow of the Type 30 CRT's P7 phospor).

   co-ordinates are as in the PDP-1 with positive axis up and right:

                 +512

      -511        0/0         +512

                 -511
*/


/*
   The testword (var testword) represents the state of an array of switches at
   the operator's console for 18-bit input.
   If Options.TESTWORDCONTROLS is set, input propagates to spaceship controls
   as follows: "high order 4 bits, rotate ccw, rotate cw, (both mean hyperspace)
   fire rocket, and fire torpedo. Low order 4 bits, same for other ship."
   -- player 1: bits 17 .. 14 (left, right, thrust, fire)
   -- player 2: bits  3 .. 0  (left, right, thrust, fire)

   bits 5 .. 10 are related to scoring (bits 6 .. 10: number of games per match)

   bits:         17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
   usage:         -PLAYER 1-          GAMES P. MATCH SC     -PLAYER 2-
   semantics:     L  R  T  F          16  8  4  2  1        L  R  T  F
                  |  |                => 0..31 GAMES        |  |
               HYPERSPACE                                HYPERSPACE

   SC: Show scores in single game mode or after the next game in match mode.
   (Here, scores will be displayed anyway.) If cleared, when resumed from a
   halt for the score display, scores are reset.
*/


// constructors (symbols/pointers of the original program in parentheses)



/* ====== implementation specific glue ====== */

// some sane setters for external use

/*
   setter for FPS, called by "setOption('FPF', <value>)" internally
   */
void setFPS(float fps) {
	if (!std::isnan(fps) && fps > 0 && fps <= 100) {
		Options.FPS = fps;
		if (timer) {
			clearInterval(timer);
			timer = setInterval(frame, floor(1000/fps));
		}
	}
}

/*
   getter for FPS
   */
float getFPS() {
	return Options.FPS;
}

/*
   setter for sense switch settings
   e.g., Spacewar.setOption( 'ANGULARMOMENTUM', true )
   or    Spacewar.setOption( 'SenseSwitch 1', true )
   */
void setOption(std::string key, int value) {
	//std::string k = key.toUpperCase().replace(/[^A-Z1-6]/g, '');
	if (key == "SENSESWITCH1")
		Options.ANGULARMOMENTUM = value;
	else if (key == "SENSESWITCH2")
		Options.LOWGRAVITY = value;
	else if (key == "SENSESWITCH3")
		Options.SINGLESHOTS = value;
	else if (key == "SENSESWITCH4")
		Options.NOBACKGROUND = value;
	else if (key == "SENSESWITCH5")
		Options.SUNKILLS = value;
	else if (key == "SENSESWITCH6")
		Options.SUNOFF = value;
	else if (key == "FPS")
		setFPS(value);
	else
		Options[key] = value;
}

/*
   getter for Options
   */
int getOption(std::string key) {
	//std::string k = String(key).toUpperCase().replace(/[^A-Z1-6]/g, "");
	if (key == "SENSESWITCH1") return Options.ANGULARMOMENTUM ;
	else if (key == "SENSESWITCH2") return Options.LOWGRAVITY;
	else if (key == "SENSESWITCH3") return Options.SINGLESHOTS;
	else if (key == "SENSESWITCH4") return Options.NOBACKGROUND;
	else if (key == "SENSESWITCH5") return Options.SUNKILLS;
	else if (key == "SENSESWITCH6") return Options.SUNOFF;
	else if (key == "FPS") return Options.FPS;
	else return Options[key];
}

/*
   setter for testword
   */
void setTestword(unsigned int n) {
	testword = n & 0x3FFFF;
}

/*
   getter for testword
   */
unsigned int getTestword() {
	return testword;
}

/*
   getter for scores, returns array [<score-ss1>, <score-ss2>]
   */
struct Scores {int s1; int s2;};
Scores getScores() {
	return {score1, score2};
}

/*
   clear/reset scores
   */
void resetScores() {
	score1 = score2 = 0;
	displayScores();
}

/*
   halt execution
   */
void halt() {
	if (timer) halted = true;
}

/*
   resume from halt
   */
void resume() {
	halted = false;
}

Spacewar::Spacewar() {
	score1 = 0;      // score spaceship 1
	score2 = 0;      // score spaceship 2
	testword = 0;
	timer = 0;
	restartCounter = 0;
	gameCounter = 0;
	halted = false;
}

